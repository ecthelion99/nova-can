{%- import 'common_macros.j2' as cm with context -%}

// Message and service callback multiplexing functions (implementations)
{%- if device.messages.receive %}
int nova_can_{{snakecase(device.name)}}_msgs_rx (NOVA_CAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for rx_message in device.messages.receive %}
        case {{rx_message.port_id}}:
        {
            {{cm.port_type_msg(rx_message.port_type)}} data_struct;
            {{cm.port_type_msg(rx_message.port_type)}}_deserialize_(&data_struct, data, length);
            return {{cm.callback_function_name(device.name, rx_message.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif -%}

{%- if device.services.server %}
int nova_can_{{snakecase(device.name)}}_servers_rx (NOVA_CAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for service in device.services.server %}
        case {{service.port_id}}:
        {
            {{cm.port_type_srv(service.port_type, True)}} data_struct;
            {{cm.port_type_srv(service.port_type, True)}}_deserialize_(&data_struct, data, length);
            return {{cm.callback_function_name(device.name, service.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif -%}

{%- if device.services.client %}
int nova_can_{{snakecase(device.name)}}_clients_rx (NOVA_CAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for service in device.services.client %}
        case {{service.port_id}}:
        {
            {{cm.port_type_srv(service.port_type, False)}} data_struct;
            {{cm.port_type_srv(service.port_type, False)}}_deserialize_(&data_struct, data, length);
            return {{cm.callback_function_name(device.name, service.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif %}

int nova_can_{{snakecase(device.name)}}_rx (void) {
    //Get can id and data from the implementation
    uint32_t can_id;
    uint8_t data[{{mtu}}];
    size_t length;
    int msg_received = nova_can_{{snakecase(device.name)}}_rx_impl(&can_id, data, &length);
    if (msg_received) {
        return 0;
    }

    // Deserialize CAN ID
    NOVA_CAN_CANID can_id_struct;
    nova_can_deserialize_canid(can_id, &can_id_struct);
    NOVA_CAN_FRAME_HEADER frame_header = nova_can_deserialize_frame_header(data);

    // This pointer could be invalid if the frame only contains a header
    uint8_t *payload = data + 1;
    length--;
    // need to implement multi-frame transfers

    // Select which multiplexing function to call based on frame type (Message, Service Request, Service Response)
    {%- if device.messages.receive %}
    if (!can_id_struct.service) {
        return nova_can_{{snakecase(device.name)}}_msgs_rx(&can_id_struct, payload, &length);
    }
    {%- endif %}
    {%- if device.services.server %}
    if (can_id_struct.service && can_id_struct.service_request) {
        return nova_can_{{snakecase(device.name)}}_servers_rx(&can_id_struct, payload, &length);
    }
    {%- endif %}
    {%- if device.services.client %}
    if (can_id_struct.service && !can_id_struct.service_request) {
        return nova_can_{{snakecase(device.name)}}_clients_rx(&can_id_struct, payload, &length);
    }
    {%- endif %}

    return 0;
}

{%- if device.messages.transmit %}
// Single-frame message transmit function using tx_impl
int nova_can_{{snakecase(device.name)}}_tx (MSG_TRANSMIT_PORT port, void *payload, uint8_t priority, bool broadcast, uint8_t destination_id) {

    // Create CAN ID struct
    NOVA_CAN_CANID can_id_struct = {
        .port_id = port,
        .service = false,
        .service_request = false,
        .priority = priority,
        .destination_id = broadcast ? 0 : destination_id,
        .source_id = NODE_ID,
    };

    // Build single-frame header
    uint8_t frame[{{mtu}}];
    NOVA_CAN_FRAME_HEADER frame_header;
    frame_header.start_of_transfer = true;
    frame_header.end_of_transfer = true;
    frame_header.transfer_id = 0;
    frame[0] = nova_can_serialize_frame_header(&frame_header);

    // Serialize payload immediately after header
    size_t payload_capacity = sizeof(frame) - 1;
    uint8_t *payload_buffer = &frame[1];

    switch (port) {
        {%- for tx_message in device.messages.transmit %}
        case NOVA_CAN_{{snakecase(device.name).upper()}}_MSG_TRANSMIT_{{snakecase(tx_message.name).upper()}}:
        {
            {{cm.port_type_msg(tx_message.port_type)}} *typed = ({{cm.port_type_msg(tx_message.port_type)}} *)payload;
            {{cm.port_type_msg(tx_message.port_type)}}_serialize_(typed, payload_buffer, &payload_capacity);
            break;
        }
        {%- endfor %}
        default:
            return -1;
    }

    size_t total_length = payload_capacity + 1; // include header
    if (total_length > sizeof(frame)) {
        return -1;
    }

    uint32_t can_id;
    nova_can_serialize_canid(&can_id_struct, &can_id);

    return nova_can_{{snakecase(device.name)}}_tx_impl(can_id, frame, total_length);
}
{%- endif %}


