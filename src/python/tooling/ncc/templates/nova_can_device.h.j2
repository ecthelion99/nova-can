{%- macro port_type_msg(port_type) -%}
{{port_type.replace('.', '_')}}
{%- endmacro -%}
{%- macro port_type_srv(port_type, request) -%}
{%- set parts = port_type.split('.') -%}
{%- set _ = parts.insert(-2, 'Request' if request else 'Response') -%}
{{'_'.join(parts)}}
{%- endmacro -%}
{%- macro callback_function_name(device_name, message_name) -%}
nova_can_{{snakecase(device_name)}}_{{snakecase(message_name)}}_callback
{%- endmacro -%}

{%- set header_guard = snakecase(device.name).upper() + '_H' -%}
#ifndef {{ header_guard }}
#define {{ header_guard }}

// Standard Library Imports
#include <stdint.h>
#include <stdbool.h>

// DSDL recieve imports
{%- if device.messages.receive %}
{%- for rx_message in device.messages.receive %}
#include <{{ dsdl_header_path(rx_message.port_type) }}>
{%- endfor %}
{%- endif %}
{%- if device.services.server %}
{%- for service in device.services.server %}
#include <{{ dsdl_header_path(service.port_type) }}>
{%- endfor %}
{%- endif %}

// Nova CAN Library Imports
#include <nova_can.h>

// Callback function declarations (implemented by user)
{%- if device.messages.receive %}
{%- for rx_message in device.messages.receive %}
int {{callback_function_name(device.name, rx_message.name)}}(NovaCAN_CANID *can_id_struct, {{port_type_msg(rx_message.port_type)}} *data);
{%- endfor %}
{%- endif %}
{%- if device.services.server %}
{%- for service in device.services.server %}
int {{callback_function_name(device.name, service.name)}}(NovaCAN_CANID *can_id_struct, {{port_type_srv(service.port_type, True)}} *data);
{%- endfor %}
{%- endif %}
{%- if device.services.client %}
{%- for service in device.services.client %}
int {{callback_function_name(device.name, service.name)}}(NovaCAN_CANID *can_id_struct, {{port_type_srv(service.port_type, False)}} *data);
{%- endfor %}
{%- endif %}

// Message and service callback multiplexing functions
{%- if device.messages.receive %}
int nova_can_{{snakecase(device.name)}}_msgs_rx (NovaCAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for rx_message in device.messages.receive %}
        case {{rx_message.port_id}}:
        {
            {{port_type_msg(rx_message.port_type)}} data_struct;
            {{port_type_msg(rx_message.port_type)}}_deserialize_(&data_struct, data, length);
            return {{callback_function_name(device.name, rx_message.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif -%}

{%- if device.services.server %}
int nova_can_{{snakecase(device.name)}}_servers_rx (NovaCAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for service in device.services.server %}
        case {{service.port_id}}:
        {
            {{port_type_srv(service.port_type, True)}} data_struct;
            {{port_type_srv(service.port_type, True)}}_deserialize_(&data_struct, data, length);
            return {{callback_function_name(device.name, service.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif -%}

{%- if device.services.client %}
int nova_can_{{snakecase(device.name)}}_clients_rx (NovaCAN_CANID *can_id_struct, uint8_t *data, size_t* length) {
    switch (can_id_struct->port_id) {
        {%- for service in device.services.client %}
        case {{service.port_id}}:
        { 
            {{port_type_srv(service.port_type, False)}} data_struct;
            {{port_type_srv(service.port_type, False)}}_deserialize_(&data_struct, data, length);
            return {{callback_function_name(device.name, service.name)}}(can_id_struct, &data_struct);
        }
        {%- endfor %}
    }
    return -1;
}
{%- endif %}

int nova_can_{{snakecase(device.name)}}_rx (uint32_t *can_id, uint8_t *data, size_t* length) {
    // Deserialize CAN ID
    NovaCAN_CANID can_id_struct;
    nova_can_deserialize_canid(*can_id, &can_id_struct);
    NOVA_CAN_FRAME_HEADER frame_header = nova_can_deserialize_frame_header(data);
    // This pointer could be invalid if the frame only contains a header
    data += sizeof(NOVA_CAN_FRAME_HEADER);
    *length -= sizeof(NOVA_CAN_FRAME_HEADER);
    // need to implement multi-frame transfers

    // Select which multiplexing function to call based on frame type (Message, Service Request, Service Response)
    {%- if device.messages.receive %}
    if (!can_id_struct.service) {
        return nova_can_{{snakecase(device.name)}}_msgs_rx(&can_id_struct, data, length);
    }
    {%- endif %}
    {%- if device.services.server %}
    if (can_id_struct.service && can_id_struct.service_request) {
        return nova_can_{{snakecase(device.name)}}_servers_rx(&can_id_struct, data, length);
    }
    {%- endif %}
    {%- if device.services.client %}
    if (can_id_struct.service && !can_id_struct.service_request) {
        return nova_can_{{snakecase(device.name)}}_clients_rx(&can_id_struct, data, length);
    }
    {%- endif %}

    return 0;
}

#endif // {{ header_guard }}
